// Takumi House (houset@bu.edu) & Kristel Tan (ktan@bu.edu)
// CAS CS410 Advanced Software Systems
// Due: November 11, 2015

// myshell.c 
// A basic shell program that parses, interprets, and executes commands

#include <stdlib.h>

#define READ_LINE_BUF_SIZE 100
#define PARSE_TOKENS_BUF_SIZE 64
#define PARSE_SPACES " \t\n"

void sigint_handler(int signum) {
	printf("Caught signal %d, coming out...\n", signum);
   	exit(1);
}

int main(void) {

	signal(SIGINT, signint_handler);			// Checks for CTRL+C signal interrupt generated by user
	char* args[READ_LINE_BUF_SIZE/2 + 1];		// Stores command line arguments

	while(1) {

		// Clear any leftover commands in args
		for (int i = 0; i < READ_LINE_BUF_SIZE/2 + 1; i++) {
            args[i] = NULL;
        }

        // Terminate myshell program if CTRL+D is typed
        if (feof(stdin) != 0) {
        	return 0; 
        }

		printf("myshell> ");								// Prompt for user to type in the shell command
		fflush(stdout);										// Clear the output buffer 

		char cmd[READ_LINE_BUF_SIZE];					
		fgets(cmd, MAX_LINE, stdin);						// Stores the first 100 characters of the command into cmd array
		int numArgs = myshell_parse_line(args, cmd);		// Parses line and returns number of arguments 

		myshell_launch(args, numArgs);						// Launches and executes given commands and arguments
	}
	return 0;
}

int myshell_parse_line(char* args, char* cmd) {

	int bufsize = PARSE_TOKENS_BUF_SIZE;
	char **tokens = malloc(sizeof(char *) * bufsize);
	int index = 0;
	char *token;

	// If index exceeds the buffer size, reallocate memory
	if (!tokens) {
		fprintf(stderr, "myshell: memory allocation failed\n");
		return EXIT_FAILURE;
	}

	// Returns pointer to the first token
	token = strtok(line, PARSE_SPACES);

	// While loop continues as long as strtok (at the end of the previous loop) returns a non-NULL value
	while(token != NULL) {
		tokens[index] = token;		// Store token into first index of tokens
		index++;					// Increment index

		if(index >= bufsize) {
			bufsize += PARSE_TOKENS_BUF_SIZE;
			tokens = realloc(tokens, bufsize * sizeof(char*));
			// If index exceeds the buffer size, reallocate memory
			if (!tokens) {
				fprintf(stderr, "myshell: memory reallocation failed\n");
				return EXIT_FAILURE;
			}
		}
		token = strtok(NULL, PARSE_SPACES);
	}
	// Set last indexed position to NULL 
	tokens[index] = NULL;
	return tokens;
}







