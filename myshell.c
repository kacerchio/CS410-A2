// Takumi House (houset@bu.edu) & Kristel Tan (ktan@bu.edu)
// CAS CS410 Advanced Software Systems
// Due: November 11, 2015

// myshell.c
// A basic shell program that parses, interprets, and executes commands

#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <signal.h>

#define MAX_LINE 100
#define PARSE_TOKENS_BUF_SIZE 64

/* Intercepts SIGINT signal and sends it to foreground processes */

void sigint_handler(int pid) {
    int ret;
    ret = kill(pid, SIGHUP);
    printf("ret : %d ", ret);
}

/* Returns true if passed in character is a special character */

int isSpecialChar(char * c) {
    
    if (strcmp(c, ";") == 0 || strcmp(c, ">") == 0 || strcmp(c, "<") == 0 || strcmp(c, "1>") == 0 ||
       strcmp(c, "2>") == 0 || strcmp(c, "&>") == 0 || strcmp(c, "&") == 0) {
        return 1;
    } else {
        return 0;
    }
}

/* Returns true if passed in character is a special character */

int isFileOperator(char * c) {
    
    if (strcmp(c, ">") == 0 || strcmp(c, "<") == 0 || strcmp(c, "1>") == 0 || strcmp(c, "2>") == 0 || strcmp(c, "&>") == 0) {
        return 1;
    } else {
        return 0;
    }
}

/* Parses commands delimited by whitespaces and returns the total number of arguments */

int myshell_parse_line(char* *args, char* cmd) {
    
    int numArg = 0;
    
    // Iterate through cmd array passed from main
    for (int i = 0; i < MAX_LINE && cmd[i] != '\n'; i++) {
        
        int start;
        int end;
        
        // Increment 'end' until a newline character or space is reached
        while (cmd[end] != '\n' && cmd[end] != ' ') {
            end++;
        }
    
        int r = end - start + 1;                        // Range of substring of argument
        char * buffer = malloc(sizeof(char*) * r);      // Allocate memory for 'buffer' based on range
        
        // Return an error if memory allocation fails
        if (!buffer) {
            fprintf(stderr, "myshell: memory allocation failed\n");
            exit(EXIT_FAILURE);
        }
        
        // Copy contents of 'cmd + start' into 'buffer'
        memcpy(buffer, cmd + start, end - start);
        buffer[r] = '\0';
    
        args[numArg] = buffer;                          // Stores substring into 'args'
        i = end;                                        // Sets index to value of 'end'
    
        // Exit out of loop if newline character is reached because this indicates there are no more commands
        if (cmd[i] == '\n') {
            break;
        }
    }
    
    return numArg;
    
}

/* Launches shell and executes given arguments */

int myshell_launch(char **args, int numArg) {
    
    int waitForChildren = 1;
    
    // Check if command is followed by an ampersand
    if (strcmp(args[numArg] - 1, "&") == 0) {
        waitForChildren = 0;                        // Sets waitForChildren to 'false'
        args[numArg - 1] = NULL;                    // ??? WHy do we set this to NULL ???
        numArg = numArg - 1;                        // Decrement 'numArg'
    }
    
    int numSpecialChars = 0;                        // Initialize special character count to 0
    int cmds = 1;                                   // If this point is reached, at least minimum number of commands is 1
    int cmdStarts[numArg];                          // Stores indices of every new command
    cmdStarts[0] = 0;                               // First command's index should always be 0
    
    char * specialChars[numArg];                    // Will store special characters
    
    // Iterates through 'args' to look for special characters
    for(int i = 0, j = 1; i < numArg; i++, j++) {
        if (isSpecialChar(args[i])) {
            cmdStarts[j] = i + 1;                   // Mark another command start index to 'cmdStarts' array
            numSpecialChars++;                      // Increment special character count
            cmds++;                                 // Increment command count
            specialChars[j - 1] = args[i];          // Store the special character into 'specialChars'
            args[i] = NULL;                         // Update current index of args to NULL because special character was accounted for
        }
    }
    
    
    
    return 0;
}

int main(void) {
    
    char* args[MAX_LINE / 2 + 1];                           // Stores command line arguments
    
    // Loops forever until terminated or interrupted
    while(1) {
        
        signal(SIGINT, sigint_handler);                     // Checks for CTRL+C signal interrupt generated by user
        
        // Iterates through 'args', clearing any leftover commands
        for (int i = 0; i < MAX_LINE / 2 + 1; i++) {
            args[i] = NULL;
        }
        
        // Terminate myshell program if CTRL+D is typed
        if (feof(stdin) != 0) {
            return 0;
        }
        
        printf("myshell> ");								// Prompt for user to type in the shell command
        fflush(stdout);										// Clear the output buffer
        
        char cmd[MAX_LINE];
        fgets(cmd, MAX_LINE, stdin);						// Stores the first 100 characters of the command into 'cmd'
        int numArgs = myshell_parse_line(args, cmd);		// Parses inputted line and returns number of arguments
        
        myshell_launch(args, numArgs);						// Launches shell and executes given arguments
    }
    return 0;
}

